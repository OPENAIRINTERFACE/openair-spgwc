/*
 * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The OpenAirInterface Software Alliance licenses this file to You under
 * the OAI Public License, Version 1.1  (the "License"); you may not use this
 *file except in compliance with the License. You may obtain a copy of the
 *License at
 *
 *      http://www.openairinterface.org/?page_id=698
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *-------------------------------------------------------------------------------
 * For more information about the OpenAirInterface (OAI) Software Alliance:
 *      contact@openairinterface.org
 */

/*! \file SpgwcContext.hpp
  \brief
  \author Lionel Gauthier
  \date 2018-2020
  \company Eurecom
  \email: lionel.gauthier@eurecom.fr
*/
#ifndef FILE_SPGWC_CONTEXT_HPP_SEEN
#define FILE_SPGWC_CONTEXT_HPP_SEEN
//--C includes -----------------------------------------------------------------
//--C++ includes ---------------------------------------------------------------
#include <map>
#include <memory>
#include <mutex>
#include <utility>
#include <vector>
//--Other includes -------------------------------------------------------------
#include "3gpp_24.008.h"
#include "3gpp_29.274.h"
#include "SpgwcProcedure.hpp"
#include "UintGenerator.hpp"
#include "common_root_types.h"
// To avoid too much reservation
#define AVERAGE_BEARERS_PER_PDN_CX 2
#define AVERAGE_PDNS_CX_PER_USER 2
#define AVERAGE_BEARERS_PER_USER 3
namespace spgwc {
//------------------------------------------------------------------------------
class EpsBearer {
 public:
  EpsBearer() { Clear(); }

  void Clear() {
    ebi_.ebi = EPS_BEARER_IDENTITY_UNASSIGNED;
    tft_ = {};
    local_fteid_sxu_ = {};
    remote_fteid_sxu_ = {};
    eps_bearer_qos_ = {};
    pdr_id_ul_ = {};
    pdr_id_dl_ = {};
    precedence_ = {};
    far_id_ul_ = {};
    far_id_dl_ = {};
    released_ = false;
  }

  void DeallocateRessources();
  void ReleaseAccessBearer();
  std::string ToString() const;

  ebi_t ebi_;
  traffic_flow_template_t tft_;
  fteid_t local_fteid_sxu_;
  fteid_t remote_fteid_sxu_;

  bearer_qos_t eps_bearer_qos_;  // EPS Bearer QoS: ARP, GBR, MBR, QCI.
  // NOT NEEDED        charging_id                  // Charging Id: Charging
  // identifier, identifies charging records generated by S-GW and PDN GW.

  // PFCP
  // Packet Detection Rule ID
  pfcp::pdr_id_t pdr_id_ul_;
  pfcp::pdr_id_t pdr_id_dl_;
  pfcp::precedence_t precedence_;
  // pfcp::pdi                         pdi;
  std::pair<bool, pfcp::far_id_t> far_id_ul_;
  std::pair<bool, pfcp::far_id_t> far_id_dl_;
  bool released_;  // finally seems necessary, TODO try to find heuristic ?
  // std::pair<bool, pfcp::urr_id_t>   urr_id;
  // std::pair<bool, pfcp::qer_id_t>   qer_id;
  // std::pair<bool, pfcp::activate_predefined_rules_t>
  // activate_predefined_rules;
};
//------------------------------------------------------------------------------
class PdnConnection : public std::enable_shared_from_this<PdnConnection> {
 public:
  PdnConnection() : eps_bearers(BEARERS_PER_UE) { clear(); }

  void clear() {
    ipv4 = false;
    ipv6 = false;
    ipv4_address.s_addr = INADDR_ANY;
    ipv6_address = in6addr_any;
    pdn_type = {};
    // local_fteid_cp = {};
    // remote_fteid_cp = {};
    default_bearer.ebi = EPS_BEARER_IDENTITY_UNASSIGNED;
    seid = 0;
    up_fseid = {};
    up_node_id = {};
    eps_bearers.clear();
    released = false;
  }

  PdnConnection(PdnConnection& b) = delete;

  //  bool get_eps_bearer(const pfcp::pdr_id_t& pdr_id, EpsBearer& b) {
  //    for (auto it : eps_bearers) {
  //      if (it.second.pdr_id_ul == pdr_id) {
  //        b = it.second;
  //        return true;
  //      }
  //      if (it.second.pdr_id_dl == pdr_id) {
  //        b = it.second;
  //        return true;
  //      }
  //    }
  //    return false;
  //  }
  //  bool get_eps_bearer(const pfcp::far_id_t& far_id, EpsBearer& b) {
  //    for (auto it : eps_bearers) {
  //      if ((it.second.far_id_ul.first) &&
  //          (it.second.far_id_ul.second.far_id == far_id.far_id)) {
  //        b = it.second;
  //        return true;
  //      }
  //      if ((it.second.far_id_dl.first) &&
  //          (it.second.far_id_dl.second.far_id == far_id.far_id)) {
  //        b = it.second;
  //        return true;
  //      }
  //    }
  //    return false;
  //  }
  //  bool get_eps_bearer(const ebi_t& ebi, EpsBearer& b) {
  //    for (auto it : eps_bearers) {
  //      if (it.second.ebi == ebi) {
  //        b = it.second;
  //        return true;
  //      }
  //    }
  //    return false;
  //  }
  // pgw_eps_bearer& get_eps_bearer(const ebi_t& ebi) {return
  // eps_bearers[ebi.ebi];}
  // void add_eps_bearer(EpsBearer& eps_bearer);
  // EpsBearer& get_eps_bearer(const ebi_t& ebi);
  // bool find_eps_bearer(const pfcp::pdr_id_t& pdr_id, EpsBearer& bearer);
  // bool HasEpsBearer(const pfcp::pdr_id_t& pdr_id, ebi_t& ebi);
  bool HasEpsBearer(const ebi_t ebi);
  void remove_eps_bearer(const ebi_t ebi);
  // void remove_eps_bearer(EpsBearer& bearer);
  void set(const paa_t& paa);

  // Called by GTPV2-C DELETE_SESSION_REQUEST
  // DeallocateRessources is for releasing LTE resources prior to the deletion
  // of objects since shared_ptr is actually heavy used for handling objects,
  // deletion of object instances cannot be always guaranteed when removing them
  // from a collection, so that is why actually the deallocation of resources is
  // not done in the destructor of objects.
  // void DeallocateRessources(const std::string& apn);
  void DeallocateRessources(std::shared_ptr<SpgwcContext> ctxt);

  std::string toString() const;

  seid_t GenerateSeid();
  void ReleaseSeid(const seid_t seid);
  pfcp::pdr_id_t GeneratePdrId();
  void ReleasePdrId(const pfcp::pdr_id_t pdr_id);
  pfcp::far_id_t GenerateFarId();
  void ReleaseFarId(const pfcp::far_id_t far_id);
  // void create_procedure(itti_s5s8_create_session_response& m);
  // void insert_procedure(SpgwcProcedure* proc);
  const bool Released(void) const { return released; };

  std::string apn_in_use;
  bool ipv4;  // IP Address(es): IPv4 address and/or IPv6 prefix
  bool ipv6;  // IP Address(es): IPv4 address and/or IPv6 prefix
  struct in_addr
      ipv4_address;  // IP Address(es): IPv4 address and/or IPv6 prefix
  struct in6_addr
      ipv6_address;     // IP Address(es): IPv4 address and/or IPv6 prefix
  pdn_type_t pdn_type;  // IPv4, IPv6, IPv4v6 or Non-IP
  // fteid_t local_fteid_cp;
  // fteid_t remote_fteid_cp;
  ebi_t default_bearer;  // Default Bearer: Identifies the default bearer within
                         // the PDN connection by its EPS Bearer Id.
  std::vector<ebi_t> eps_bearers;
  bool released;  //(release access bearers request)

  //----------------------------------------------------------------------------
  // PFCP related members
  //----------------------------------------------------------------------------
  // PFCP Session
  pfcp::node_id_t up_node_id;
  uint64_t seid;
  pfcp::fseid_t up_fseid;
  // Spec says Ids are valid in the scope of a pdn connection, but
  // for less memory let this be static.
  static util::UintGenerator<seid_t> seid_generator;
  static util::UintGenerator<uint16_t> pdr_id_generator;
  static util::UintGenerator<uint32_t> far_id_generator;
};
//------------------------------------------------------------------------------
class ApnContext {
 public:
  ApnContext() : in_use(false), pdn_connections(2) { apn_ambr = {0}; }

  ApnContext(ApnContext& b) = delete;

  void InsertPdnConnection(std::shared_ptr<PdnConnection>& sp);
  // bool FindPdnConnection(const teid_t xgw_s5s8c_teid, const bool
  // is_local_teid,
  //                       std::shared_ptr<PdnConnection>& pdn);
  // bool FindPdnConnection(const pfcp::pdr_id_t& pdr_id,
  //                       std::shared_ptr<PdnConnection>& pdn, ebi_t& ebi);
  void DeletePdnConnection(std::shared_ptr<PdnConnection> pdn_connection,
                           std::shared_ptr<SpgwcContext> t_visited);
  int GetNumPdnConnections() const { return pdn_connections.size(); };
  // DeallocateRessources is for releasing LTE resources prior to the deletion
  // of objects since shared_ptr is actually heavy used for handling objects,
  // deletion of object instances cannot be always guaranteed when removing them
  // from a collection, so that is why actually the deallocation of resources is
  // not done in the destructor of objects.
  void DeallocateRessources(std::shared_ptr<SpgwcContext> t_visited){};

  std::string toString() const;

  bool in_use;
  std::string apn_in_use;  // The APN currently used, as received from the SGW.
  ambr_t apn_ambr;  // APN AMBR: The maximum aggregated uplink and downlink MBR
                    // values to be shared across all Non-GBR bearers, which are
                    // established for this APN.
  // APN Rate Control: The APN-Rate-Control limits the maximum number of
  // uplink/downlink packets and the maximum number of
  //                   additional exception report packets per a specific time
  //                   unit (e.g. minute, hour, day, week) for this APN. It
  //                   includes an indication as to whether or not Exception
  //                   reports may still be sent when the limit has been met.
  // key is local s5s8 teid
  // map<teid_t, shared_ptr<PgwPdnConnection>> pdn_connections;
  std::vector<std::shared_ptr<PdnConnection>> pdn_connections;  // was list
};
//------------------------------------------------------------------------------
class SpgwcContext;

typedef std::pair<std::shared_ptr<ApnContext>, std::shared_ptr<PdnConnection>>
    apn_pdn_t;

class SpgwcContext : public std::enable_shared_from_this<SpgwcContext> {
 public:
  SpgwcContext()
      : imsi_(),
        imsi_unauthenticated_indicator_(false),
        apns_(3),
        bearers_(AVERAGE_BEARERS_PER_USER),
        pdn_cx_(AVERAGE_PDNS_CX_PER_USER),
        pending_procedures_(3),
        msisdn_() {}

  SpgwcContext(SpgwcContext& b) = delete;

  void InsertProcedure(std::shared_ptr<SpgwcProcedure> sproc);
  std::pair<const bool, std::shared_ptr<SpgwcProcedure>> FindProcedure(
      const uint64_t t_trxn_id);
  void RemoveProcedure(std::shared_ptr<SpgwcProcedure> proc);

  std::pair<const bool, std::shared_ptr<EpsBearer>> FindBearer(const ebi_t ebi);
  std::tuple<const bool, std::shared_ptr<ApnContext>,
             std::shared_ptr<PdnConnection>>
  FindPdnConnection(const std::string& t_apn, pdn_type_t t_pdn_type);
  std::pair<const bool, std::shared_ptr<PdnConnection>>
  FindPdnConnectionByDefaultEbi(const ebi_t linked_ebi);
  std::pair<const bool, std::shared_ptr<PdnConnection>> FindPdnConnection(
      const ebi_t t_ebi);
  std::tuple<const bool, std::shared_ptr<PdnConnection>, const ebi_t>
  FindPdnConnection(const pfcp::pdr_id_t pdr_id);
  std::pair<const bool, std::vector<std::shared_ptr<PdnConnection>>>
  FindPdnConnectionsByReleaseState(const bool t_released);
  // bool FindPdnConnection(const pfcp::pdr_id_t& pdr_id,
  //                       std::shared_ptr<PdnConnection>& pdn, ebi_t& ebi);
  void InsertApn(std::shared_ptr<ApnContext> sa);
  std::pair<const bool, std::shared_ptr<ApnContext>> FindApnContext(
      const std::string& apn);

  // int GetNumApnContexts() { return apns.size(); };

  void DeleteBearer(const ebi_t ebi);
  void DeleteApnContext(std::shared_ptr<ApnContext> sa);
  void DeletePdnConnection(std::shared_ptr<PdnConnection> sp);

  void ProcessMsg(
      std::unique_ptr<gtpv2c::Gtpv2cCreateSessionRequest> s11_trigger,
      const EndPoint& remote_endpoint, const teid_t local_teid,
      const uint64_t trxn_id);
  void ProcessMsg(
      std::unique_ptr<gtpv2c::Gtpv2cDeleteSessionRequest> s11_trigger,
      const EndPoint& remote_endpoint, const teid_t local_teid,
      const uint64_t trxn_id);
  void ProcessMsg(
      std::unique_ptr<gtpv2c::Gtpv2cModifyBearerRequest> s11_trigger,
      const EndPoint& remote_endpoint, const teid_t local_teid,
      const uint64_t trxn_id);
  void ProcessMsg(
      std::unique_ptr<gtpv2c::Gtpv2cReleaseAccessBearersRequest> s11_trigger,
      const EndPoint& remote_endpoint, const teid_t local_teid,
      const uint64_t trxn_id);
  void ProcessMsg(
      std::unique_ptr<gtpv2c::Gtpv2cDownlinkDataNotificationAcknowledge> r,
      const EndPoint& remote_endpoint, const teid_t local_teid,
      const uint64_t trxn_id);
  void ProcessMsg(std::unique_ptr<pfcp::PfcpSessionEstablishmentResponse> r,
                  const EndPoint& remote_endpoint, const seid_t local_seid,
                  const uint64_t trxn_id);
  void ProcessMsg(std::unique_ptr<pfcp::PfcpSessionModificationResponse> r,
                  const EndPoint& remote_endpoint, const seid_t local_seid,
                  const uint64_t trxn_id);
  void ProcessMsg(std::unique_ptr<pfcp::PfcpSessionDeletionResponse> r,
                  const EndPoint& remote_endpoint, const seid_t local_seid,
                  const uint64_t trxn_id);
  void ProcessMsg(std::unique_ptr<pfcp::PfcpSessionReportRequest> r,
                  const EndPoint& remote_endpoint, const seid_t local_seid,
                  const uint64_t trxn_id);
  bool AddBearer(const EpsBearer& b, std::shared_ptr<spgwc::PdnConnection> pdn);
  std::pair<const bool, std::shared_ptr<EpsBearer>> GetBearer(
      const pfcp::pdr_id_t pdr_id);
  std::pair<const bool, std::shared_ptr<EpsBearer>> GetBearer(
      const pfcp::far_id_t far_id);
  std::pair<const bool, std::shared_ptr<EpsBearer>> GetBearer(const ebi_t ebi);

  std::string toString() const;

  imsi_t imsi_;  // IMSI (International Mobile Subscriber Identity) is the
                 // subscriber permanent identity.
  bool imsi_unauthenticated_indicator_;  // This is an IMSI indicator to show
                                         // the IMSI is unauthenticated.

  msisdn_t msisdn_;  // The basic MSISDN of the UE. The presence is dictated by
  fteid_t mme_fteid_s11_;
  fteid_t sgw_fteid_s11_s4_cp_;
  // fteid_t sgsn_fteid_s4_cp;
  ecgi_field_t last_known_cell_Id_;  // This is the last location of the UE
                                     // known by the network

  std::vector<std::shared_ptr<ApnContext>> apns_;  // was list
  std::vector<std::shared_ptr<EpsBearer>> bearers_;
  std::vector<std::shared_ptr<PdnConnection>> pdn_cx_;

  //--------------------------------------------
  // internals
  std::vector<std::shared_ptr<SpgwcProcedure>> pending_procedures_;
};
}  // namespace spgwc

#endif /* FILE_SPGWC_CONTEXT_HPP_SEEN */
